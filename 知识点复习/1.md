- 方程解的个数：插板法

- 可见的点：欧拉函数

- 最大公约数:求求1<=x,y<=N且GCD(x,y)为素数的数对(x,y)有多少对。，欧拉函数（0，到n画图）

- 公牛中间放k个母牛

- - Dp：f[I] :前i个牛的方案数，第i个是公牛、母牛，这是状态转移

- 卡特兰数

- 样例 3 5（大概率卡特兰数）第3个卡特兰数：5

- 把某个阶乘分解质因数，不能乘起来再分解，

- 计算C(a，b)不能用Lucas的话，用阶乘分解质因子

- - 

  

# 问至少修改S的多少个字符，可以令T成为S的子序列。

DP:子串的初始化，初始化考虑空串的任何串的子串

```CPP
if(a[i]==b[j]) f[i][j]=min(f[i][j],f[i-1][j-1]);
 else{
         f[i][j]=min(f[i-1][j] , f[i-1][j-1]+1);
 }
```

# 概率DP

要抽象出：起点、中点

转移的时候：一个点转移到n个点，然后记忆化

## 有向无环图中整DP

有向无环图求起点到终点的概率

- 正向图推是错误的，需要反向推
- 可以记忆化搜索

## 扑克牌的期望DP

* 状态转移：抽出一张牌放入分类
* 状态表示：每种牌有多少个，大王、小王代替什么牌
* 转移：按照当前取的牌放到哪种，可以由一个状态变为多个状态
* 起点：当前没有拿牌
* 终点：把牌放完，终点概率为0
* 拿一张牌的期望为1，在此基础上+=其他可以变化的状态



# 单调队列优化DP

* 初始化记得处理下标，从左循环q[0]=0,从右循环q[0]=n+1
* 先判断长度
* 然后处理dp
* 最后加入队列
* 例题：
  * 前缀和那些，前x一段距离最大、最小值，队列长度x+1
  * 区间里面连续m不选，区间里面连续m+1个选一个

## 修剪草坪

### 思路1

* 长度为m+1的序列必须不选择1个的最大值
* 反过来想，长度为m+1的序列中至少选择一个，选出来最小值，然后总和处理
* f[i] :前i个序列最后一个序列选的最小值
  * 转移：在i前面的m+1个f[i] 中选择最小的 + a[i] 
  * 长度为m+1中f[i] 的最小值，单调队列优话

### 思路2

* 定义状态f[i] :前i个序列中合法的序列最大值

* 第i个数选、不选

  * 不选：f[i-1]

  * 选

    * 选上这个点+之前的连续选点长度为1<=x<=m

    * 转移：f[i-x-1] + a[i-x+1] +a[i-x+3] +--- a[i];(i-x那个点不选，中间忽略掉)

    * 用前缀和处理一下

    * max(f[i-x-1] + sum[i] - sum[i-x])  (1 <= x<=m)

    * x是i的前几个变量，这些变量的最大值，用单调队列优化，把sum[i] 提出来

    * max(f[i-x-1] + sum[i-x]) +sum[i]：前m个

    * 把那个方程处理一下，处理成一个函数

      ```cpp
      ll g(int x)
      {
          if(!x ) return 0;
          return f[x-1] - sum[x];
      
      }
      ```

      

## 旅行问题

环形：2倍空间处理

判断中间有没有油：油的前缀和 - 路程的前缀和

顺时针，前缀和。逆时针，后缀和

## 二维滑动窗口

* 先滑动窗口行方向的最大值
* 然后列方向处理