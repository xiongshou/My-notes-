# 背包



## 状态表示：

最多：全部为0，枚举体积为正数

恰好：f[0]= 0 , 其他不存在，枚举体积为正数

至少：f[0]=0,其他不存在，体积是负数也合理，下标用max（0）处理一下

---

### 宠物小精灵之收服

* 体力值不能为0，所以枚举体力要从m-1开始

### 货币系统

* 最小独立集的概念
* 先排序，然后每个物品先判断能不能用之前的完全背包出来
* 然后，把这个物品放入完全背包跑一下

###  机器分配

* 抽象出分组背包
* 输出路径：看转移方程

### 能量石

* 贪心求出：按照整样的顺序吃石头
* 01背包：按照顺序吃不吃这个石头
* 体积：用时间处理
* f[i] [j]:前i个物品，时间为j吃的价值

### 金明的预算方案

* 抽象出分组背包
* 每组物品，用2进制枚举决策
* 枚举物品
* 枚举体积
* 枚举决策

### 有依赖的背包问题

```cpp
void dfs(int u)
{
    for (int i = h[u]; ~i; i = ne[i])   // 循环物品组
    {
        int son = e[i];
        dfs(e[i]);

        // 分组背包
        for (int j = m - v[u]; j >= 0; j -- )  // 循环体积
            for (int k = 0; k <= j; k ++ )  // 循环决策
                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);
    }

    // 将物品u加进去
    for (int i = m; i >= v[u]; i -- ) f[u][i] = f[u][i - v[u]] + w[u];
    for (int i = 0; i < v[u]; i ++ ) f[u][i] = 0;
}
```



# 状态机

## 大盗阿福

* 第i个位置偷或者不偷

### 股票买卖

* 买卖k次：多加一维度表示买了几次
* 手里有无货
* 初始化，一次不交易都是0，其他都是不存在

### 股票买卖（带冷冻期）

* 三种状态
* ![image-20201112220757165](https://tva1.sinaimg.cn/large/0081Kckwly1gkmqrulqt2j31lo0i0jyh.jpg)

### 设计密码

设计一个长度为n，不包含一个子串的字符串，求一下，字符串总数

s[i] 和p[j+1] 一起跳

```cpp
for(char u='a';u<='z';u++)
{
      int ne_j=j;
      while(ne_j && u!=s[ne_j+1]) ne_j=ne[ne_j];
      if(u==s[ne_j+1]) ne_j++;
      if(ne_j<m)
           f[i+1][ne_j] = (f[i+1][ne_j] + f[i][j]) %mod;
}
```

## 区间DP

---

### 能量项链

### 加分二叉树

* DP中记录区间根节点，然后递归输出，可以输出数的遍历



# 树形DP

## 树的重心

## 树的最长路径

* 向下最长、次长

### 树的中心

* 向下最长、向下次长、向上最长、判断是不是叶子节点

* 向上最长

* ```cpp
  void dfs_u(int u, int father)
  {
      for (int i = h[u]; i != -1; i = ne[i])
      {
          int j = e[i];
          if (j == father) continue;
  
          if (p1[u] == j) up[j] = max(up[u], d2[u]) + w[i];
          else up[j] = max(up[u], d1[u]) + w[i];
  
          dfs_u(j, u);
      }
  }
  ```

### 数子转换

* 转换为倍数关系
* 然后最长路径

### 战略游戏

* f[u] [0] :节点u不放，1：



# 最短路

## 通信线路

* 二分+最短路
* 最短路权重01
* 在最短路里面更新比较一下，没必要暴力建图

## 最优贸易

* 反图

## 观光

* 次短路条数
* 放入堆里面：id、type、dist

# flold

* 输出最小环

# 负环

## 环中点权和-边权和 最大，求最大值

* 二分答案，根据有没有环来cheak
* spfa边权变换一下

## 二分答案，看图中有没有正环

* 跑最长路，然后计数

# 差分约束

* 无解存在负权回路
* 最小值，跑最长路（看转移条件）
  * dis[v]>=dis[u] + w :  u - >v
* 最大值，跑最短路（看转移条件）
  * Dis[v]<=dis[u]+w

## 糖果

* 差分条件多加一个源点

## 区间

* 差分条件
* 构成前缀和序列
  * 这个点要么是0 要么是1
  * sum[i] - sum[i-1] >=0
  * Sum[i]-sum[i-1]<=1



## 基友、敌人关系

* 差分条件：直接写
* 不存在：有环
* 无限大：dis[n] = INF
* 有解：dis[n]



# 二分图

## 关押罪犯

* 二分+染色法判断二分图

## 棋盘覆盖

* 奇偶格二分图
* 奇数向偶数find
* 每次find之前memset（st）

## 点覆盖所有的边

* 最大匹配数

## 最小路径重复点覆盖

* 传递闭包
* 点数-最大匹配数

# 欧拉路径、欧拉回路

![image-20201113173212129](https://tva1.sinaimg.cn/large/0081Kckwly1gknof7vuwmj317o0kwtr0.jpg)

## 输出字典序最小的欧拉路径

```cpp
void dfs(int u)
{
    for (int i = 1; i <= n; i ++ )
        if (g[u][i])
        {
            g[u][i] --, g[i][u] -- ;
            dfs(i);
        }
    ans[ ++ cnt] = u;
}
```

## 度数关系&是不是连通



# 拓扑排序

## 可达性统计

![image-20201113174505297](https://tva1.sinaimg.cn/large/0081Kckwly1gknoskzptnj31470u0jyv.jpg)

先拓扑排序，按照逆序dp：bitset表示

## 车站分级

一个集合中，一部分点的价值大于一个数。

抽象一下：

* 这部分点的价值> 剩下点的价值
* 依据这个建立差分约束
* 跑最长路，因为有解，所有使用拓扑排序求最长路
* 若用spfa跑的话，入度为0的点连上虚拟源点跑spfa



# 数学

*  一个的最小正整数解：一顿模除，模除：另外一个系数/gcd





# DP

## 鸣人的影分身（整数划分）

![image-20201113205926559](https://tva1.sinaimg.cn/large/0081Kckwly1gknuetera5j315u0oq442.jpg)

## 波动序列（数学表达式转化为模数）

![image-20201113210212885](https://tva1.sinaimg.cn/large/0081Kckwly1gknuhot773j319m0gmwh9.jpg)

## 糖果

* 加一个模维度

## 最长回文子串（区间DP求）

```cpp
if(str[l]==str[r])  f[l][r]=max(f[l][r],f[l+1][r-1] + 2);
                f[l][r]=max(f[l][r],f[l+1][r]);
                f[l][r]=max(f[l][r-1],f[l][r]);
```

## 包子凑数

裴蜀定理 ，任意两个数的组合必定是他们gcd的任意两个数的组合必定是他们gcd的倍数

若gcd！=1，那么这些数字不能凑出无限个数

## 括号配对

类似求一下最长回文子串的区间DP

* 若区间端点俩个匹配，res+=2
* 如果 A 与 B 都是 GBE，那么 AB 是 GBE
* 用枚举中间点，处理一下

## 树的最长路径



# 线段树

迷一样的牛

* 二分+树状数组